<html>
<head>
<title>Plus3.html</title>
<meta charset="utf-8"/>
<style>
  td {text-align:right; font-size:1.15em; white-space:nowrap}
  .td {min-width:70; height:2em}
  .yx {background-color:white}
  .xy {background-color:Gainsboro}
  .xx {background-color:LavenderBlush}
  .yy {background-color:Azure}
  .pxy {min-width:1.5em; background-color:LightGray}
  .pxx {min-width:1.5em; background-color:orange}
  .pyy {min-width:1.5em; background-color:aqua}
  .pyx {min-width:1.5em; background-color:white}
  </style>
<script>
var Ausgangsmarix=[];
var gemeinsamer_Nenner=1;
var m=0;
var n=0;
var D=[];
var B=[];
var LCode="";
var HCode="";
var HCode2="";
var HCode_Matrix_2="";
var p=[];
var hist=[];
let U=[];
let V=[];
let Yi=[];//war Ui
let Xj=[];//war Vj
let d=0;
let AMERK=[];
let g=0;
let h=0;
let k=0;
let l=0;
let sign=1;
let signarray=[];

function Los() {
  //alert(document.getElementById("input").value);
  eval(document.getElementById("input").value);
  m=Ausgangsmatrix.length;
  n=Ausgangsmatrix[0].length;
  for (var i=0;i<m;i++) for (var j=0;j<n;j++) Ausgangsmatrix[i][j]=BigInt(Ausgangsmatrix[i][j]);
  gemeinsamer_Nenner=BigInt(gemeinsamer_Nenner);
  LCode="m="+m+"\nn="+n+";\n";
  D=[]; for (var j=0;j<n;j++) D[j]=j;
  B=[]; for (var i=0;i<m;i++) B[i]=-1-i;
  U=[];
  V=[];
  Yi=[];
  Xj=[];

  hist=[];
  p=[0,0,0,0,0];
  AMERK=structuredClone(Ausgangsmatrix);
  bestimme_Matrix_2();
  bestimme_Matrix_3();
  Ausgabe();
  }

function tausche(r,s) {
  //alert("[ ["+Ausgangsmatrix.join("],\n  [")+"] ] / "+gemeinsamer_Nenner);  
  m=Ausgangsmatrix.length;
  n=Ausgangsmatrix[0].length;
  //alert(m+" "+n);
  sign=signarray[r][s];
  var neueMatrix=[];
  var neuerNenner=Ausgangsmatrix[r][s];
  if (neuerNenner==0) {alert('da entsteht Division durch Null, deshalb anderen Koeffizient auswählen'); return}
  for (var i=0;i<m;i++) {
    neueMatrix[i]=[];
    for (var j=0;j<n;j++) {
      if (i==r&&j==s) neueMatrix[i][j]=gemeinsamer_Nenner*sign;
      if (i!=r&&j==s) neueMatrix[i][j]=Ausgangsmatrix[i][j]*sign;
      if (i==r&&j!=s) neueMatrix[i][j]=-Ausgangsmatrix[i][j]*sign;
      if (i!=r&&j!=s) neueMatrix[i][j]=(Ausgangsmatrix[i][j]*neuerNenner-Ausgangsmatrix[i][s]*Ausgangsmatrix[r][j])/gemeinsamer_Nenner*sign;
      }
    }
  Ausgangsmatrix=neueMatrix;
  gemeinsamer_Nenner=neuerNenner*sign;
  //alert("r="+r+"; s="+s+";\n\n[ ["+Ausgangsmatrix.join("],\n  [")+"] ] / "+gemeinsamer_Nenner);
  }

function alt(bi) { if (bi<0) return n-bi-2; else return bi; }
function neu(bi) { if (bi<n) return bi; else return n-bi-2; }
function xy(bi) { if (bi<n) return "x"+bi; else if (bi<n+m-1) return "y"+(bi-n+1); else return 0;}

function t(r,s) {
  if (Ausgangsmatrix[r][s]==0) return;
  hist.push([r,s]);
  p=[r,s,r,s];
  var merk=B[p[2]];
  B[p[2]]=D[p[3]];
  D[p[3]]=merk;
  tausche(p[2],p[3]);
  V=[]; for (let i=0;i<B.length;i++) if (B[i]>=0) V.push(B[i]); V.sort();
  U=[]; for (let i=0;i<D.length;i++) if (D[i]<0) U.push(-D[i]-1); U.sort();
  bestimme_Matrix_2();
  bestimme_Matrix_3();
  Ausgabe();
  }

let dgh=0,dgl=0,dkh=0,dkl=0;
let npiv2=[g,h,d];
let npiv3=[g,h,k,l,[dgh,dgl,dkh,dkl]];

function Ausgabe() {
  LCode="D=["+D+"];\nB=["+B+"];\np=["+[neu(p[0]),neu(p[1]),p[2],p[3],p[4]]+"];\n"
    +'U=['+U+'];\n'
    +'V=['+V+'];\n'
    +"-------\n"+LCode;
  if (LCode.length>10000) LCode=LCode.slice(0,50000);
  HCode=Ausgabe_HCode(Ausgangsmatrix,gemeinsamer_Nenner,B,D,p);
  document.getElementById("Logfile").firstChild.nodeValue=LCode;
  document.getElementById("HCode").innerHTML=HCode;
  //document.getElementById("Pivot").click();
  Pivot.click();
  HCode_Matrix_2=Ausgabe_HCode(Matrix_2,gemeinsamer_Nenner,B,D,p,npiv2);
  document.getElementById("id_HCode_Matrix_2").innerHTML=HCode_Matrix_2;
  Pivot2.click();
  HCode_Matrix_3=Ausgabe_HCode(Matrix_3,gemeinsamer_Nenner,B,D,p,npiv3);
  document.getElementById("id_HCode_Matrix_3").innerHTML=HCode_Matrix_3;
  Pivot3.click();
  }

function Ausgabe_Logfile(Ausgangsmatrix,gemeinsamer_Nenner,B,D,p) {
  var T=Ausgangsmatrix.join("],\n  [")+"] ] / "
    +gemeinsamer_Nenner+"\n\nB=["+B+"]; D=["+D+"];"
    +"\n\nr="+p[0]+"; s="+p[1]+"; ri="+p[2]+"; sj="+p[3]+";\n";
  return T;
  }

let Checkbit_Nenner=false;
let td_class="";
let XjMat=[];
let YiMat=[];
let Pivot_i=1;
let Pivot_j=1;
let Pivot2_i=0;
let Pivot2_j=2;
let Pivot3_i=3;
let Pivot3_j=1;
function Ausgabe_HCode(Ausgangsmatrix,gemeinsamer_Nenner,B,D,p,npiv) {
  if (npiv) if (npiv.length==3) {AMERK[npiv[0]][npiv[1]]=AMERK[npiv[0]][npiv[1]]+npiv[2]; gemeinsamer_Nenner=neuer_gemeinsamer_Nenner} else {
    AMERK[npiv[0]][npiv[1]]=AMERK[npiv[0]][npiv[1]]+npiv[4][0];
    AMERK[npiv[0]][npiv[3]]=AMERK[npiv[0]][npiv[3]]+npiv[4][1];
    AMERK[npiv[2]][npiv[1]]=AMERK[npiv[2]][npiv[1]]+npiv[4][2];
    AMERK[npiv[2]][npiv[3]]=AMERK[npiv[2]][npiv[3]]+npiv[4][3];
    gemeinsamer_Nenner=neuer_gemeinsamer_Nenner3;
    };
  if (Checkbox_Nenner.checked&&(gemeinsamer_Nenner<0)) {
    for (var i=0;i<m;i++) for (var j=0;j<n;j++) Ausgangsmatrix[i][j]=-Ausgangsmatrix[i][j];
    gemeinsamer_Nenner=-gemeinsamer_Nenner;
    Checkbit_Nenner=true;
    }

  var T='<div style="display:flex; overflow:auto"><table style="box-sizing: border-box" border="0">\n';
  HCode2='<table style="text-align:right"><tbody>\n';
  var Nenner=gemeinsamer_Nenner;
//  if (p[2]>0&&p[3]>0) Nenner=1;
  let determ=det(AUV(U,V));
  let signd=1n;
  let signx=1n;
  signarray=[];
  if (determ!=Nenner) signd=-1n;
  Yi=U.slice();Xj=V.slice();
  T=T+"<!-"+"-tr>";
  for (var j=0;j<n;j++) {
      T=T+"<td>";
      if (D[j]>=0) T=T+"x<sub>"+D[j]+"</sub></td>"; 
        else T=T+"y<sub>"+(-1-D[j])+"</sub></td>";
      }
  T=T+"<td>"+Nenner+'<sub><small><small>'+determ+/*'<br/>'+AUV(U,V).join('<br/>')+'<br/>U='+U+'<br/>V='+V+*/"</small></small></sub></td>";
  T=T+'</tr-'+'->\n';
  XjMat=[];
  YiMat=[];
  let bis_jetzt_noch_kein_Fehler=true;
  for (let i=0;i<m;i++) {
    signarray[i]=[];
    T=T+'<tr>';
    HCode2=HCode2+'<tr>\n';
    XjMat[i]=[];
    YiMat[i]=[];
    for (let j=0;j<n;j++) {
      T=T+'<td ';
      HCode2=HCode2+'  <td ';
      signx=1;
      let sty="border:solid white;";
      if (i==Pivot_i&&j==Pivot_j) if (npiv) ; else {T=T+'id="Pivot" '}
      if (i==Pivot2_i&&j==Pivot2_j) if (npiv) if (npiv.length==3) {T=T+'id="Pivot2" '}
      if (i==Pivot3_i&&j==Pivot3_j) if (npiv) if (npiv.length>3) {T=T+'id="Pivot3" '}
      if (i==p[2]&&j==p[3]) sty="border:solid black;"
      Yi=U.slice();Xj=V.slice();
      if (B[i]<0&&D[j]>=0) {
        td_class="yx";
        k=-1-B[i]; l=D[j];
        Xj.push(l); Xj.sort();
        Yi.push(k); Yi.sort();
        signx=(-1)**(Yi.indexOf(k)+Xj.indexOf(l));
        }
      if (B[i]>=0&&D[j]>=0) {
        td_class="xx";
        h=B[i]; l=D[j];
        Xj.push(l); Xj.sort(); let Xjmerk=Xj.slice();
        signx=(-1)**(Xj.indexOf(l)+Xj.indexOf(h));
        Xj=[]; for(let p=0;p<Xjmerk.length;p++) if (Xjmerk[p]!=h) Xj.push(Xjmerk[p]);
        }
      if (B[i]<0&&D[j]<0) {
        td_class="yy";
        k=-1-B[i]; g=-1-D[j];
        Yi=[]; for(let p=0;p<U.length;p++) if (U[p]!=g) Yi.push(U[p]); Yi.push(k); Yi.sort();
        signx=(-1)**(Yi.indexOf(k)+U.indexOf(g));
        }
      if (B[i]>=0&&D[j]<0) {
        td_class="xy";
        h=B[i]; g=-1-D[j];
        Yi=[]; for(let p=0;p<U.length;p++) if (U[p]!=g) Yi.push(U[p]);
        Xj=[]; for(let p=0;p<V.length;p++) if (V[p]!=h) Xj.push(V[p]);
        signx=(-1)**(V.indexOf(h)+U.indexOf(g));
        }
      XjMat[i][j]=Xj;
      YiMat[i][j]=Yi;
      signarray[i][j]=BigInt(signx);
      //let err=Error('determ!=Ausgangsmatrix[i][j]');//alert(err);
      determ=BigInt(signd)*BigInt(signx)*(det(AUV(Yi,Xj)));
      if (determ!=Ausgangsmatrix[i][j]/*||determ<-10000*/) {
        T=T+' style="border:solid red 5px";'; 
        err=true;
        if (npiv) if (determ!=-Ausgangsmatrix[i][j]) if (bis_jetzt_noch_kein_Fehler) {
          alert('Error: determ!=Ausgangsmatrix[i][j]\n'+determ+'\n'+Ausgangsmatrix[i][j]);
          bis_jetzt_noch_kein_Fehler=false;
          } 
        }
      let sty2='border:solid white;';
      if (Ausgangsmatrix[i][j]==0) {sty=sty+' color:white;'; sty2=sty2+" color:white;"}
      //alert(sty);
      T=T+'class="td '+td_class+'" style="'+sty2+'" onclick="Berechnung_Koeffizient_aus_J('+i+','+j+',\''+td_class+'\'';
      if (npiv) T=T+',['+npiv+']';
      T=T+')">';
      HCode2=HCode2+'class="'+td_class+'">';
      if (Ausgangsmatrix[i][j]>=0) {T=T+"+"; HCode2=HCode2+'+'}
      T=T+(Ausgangsmatrix[i][j])+/*'<sub><small><small><small>'+determ+'<br/>'+signx+'<br/>'+AUV(Yi,Xj).join('<br/>')+'<br/>Yi='+Yi+'<br/>Xj='+Xj+'</small></small></small></sub>'+*/'</td>';
      HCode2=HCode2+(Ausgangsmatrix[i][j])+'</td>';
      T=T+'<td class="'+td_class+'" style="'+sty+'" onclick="t('+i+","+j+')">';
      HCode2=HCode2+'<td class="'+td_class+'">';
      if (D[j]>=0) {
        T=T+"· x<sub>"+D[j]+"</sub>";
        HCode2=HCode2+"· x<sub>"+D[j]+"</sub>";        
        } else {
          T=T+"· f<sup>"+(-1-D[j])+"</sup>";
          HCode2=HCode2+"· f<sup>"+(-1-D[j])+"</sup>";
          }    
      T=T+"</td>";
      HCode2=HCode2+'</td>\n';
      }
    T=T+'<td>=</td><td class="td" style="border:solid white"';
    if (npiv) ; else { 
      T=T+' onclick="Berechnung_Koeffizient_aus_J('+i+',-1,0)"';
      if (i==Pivot_i&&-1==Pivot_j) T=T+' id="Pivot" ';
      }
    T=T+'>'+Nenner+'</td><td>·</td>';
    HCode2=HCode2+'  <td>=</td>\n  <td>';
    if (B[i]<0) {
      T=T+"<td>f<sup>"+(-1-B[i])+"</sup></td>";
      HCode2=HCode2+'<td>f<sup>'+(-1-B[i])+'</sup></td>';
      } else {
        T=T+'<td class="xx">x<sub>'+(B[i])+'</sub></td>';
        HCode2=HCode2+'<td class="xx">x<sub>'+(B[i])+'</sub></td>';
        }
    T=T+'</tr>\n';
    HCode2=HCode2+'\n  </tr>\n';
    }
//  T=T+Ausgangsmatrix.join("],\n  [")+"] ] / "
//    +gemeinsamer_Nenner+"\n\nB=["+B+"]; D=["+D+"];"
//    +"\n\nr="+p[0]+"; s="+p[1]+"; ri="+p[2]+"; sj="+p[3]+";\n";
  T=T+"</table></div>";
  HCode2=HCode2+'</tbody></table>\n';

  //alert(T.slice(900));
  if (Checkbit_Nenner) {
    for (var i=0;i<m;i++) for (var j=0;j<n;j++) Ausgangsmatrix[i][j]=-Ausgangsmatrix[i][j];
    gemeinsamer_Nenner=-gemeinsamer_Nenner;
    Checkbit_Nenner=false;
    }
  if (npiv) if (npiv.length==3) {AMERK[npiv[0]][npiv[1]]=AMERK[npiv[0]][npiv[1]]-npiv[2]; gemeinsamer_Nenner=alter_gemeinsamer_Nenner} else {
    AMERK[npiv[0]][npiv[1]]=AMERK[npiv[0]][npiv[1]]-npiv[4][0];
    AMERK[npiv[0]][npiv[3]]=AMERK[npiv[0]][npiv[3]]-npiv[4][1];
    AMERK[npiv[2]][npiv[1]]=AMERK[npiv[2]][npiv[1]]-npiv[4][2];
    AMERK[npiv[2]][npiv[3]]=AMERK[npiv[2]][npiv[3]]-npiv[4][3];
    gemeinsamer_Nenner=alter_gemeinsamer_Nenner3;
    };
  return T;
  }
  </script>

<script>
function AUV(Yi,Xj) {
  let RET='';
  let M=[];
  for (let k=0;k<Yi.length;k++) {
    let Mi=[];
    for (let l=0;l<Xj.length;l++) Mi.push(AMERK[Yi[k]][Xj[l]]);
    M.push(Mi);
    }
  return M;
  }
  </script>

<script>
function det(Ausgangsmatrix) {
  let gemeinsamer_Nenner=1n;
  //alert("[ ["+Ausgangsmatrix.join("],\n  [")+"] ] / "+gemeinsamer_Nenner);
  let m=Ausgangsmatrix.length;
  if (m==0) return 1n;
//  return Math.round(determinantOfMatrixIterative(Ausgangsmatrix,m));
  let ret= determinantOfMatrixRecursive(Ausgangsmatrix,m);
  //alert('ret '+ret);
  return ret;
  let n=Ausgangsmatrix[0].length;
  //alert(m+" "+n);
for (let r=0;r<m;r++) {let s=r;
  var neueMatrix=[];
  var neuerNenner=Ausgangsmatrix[r][s];
  for (var i=0;i<m;i++) {
    neueMatrix[i]=[];
    for (var j=0;j<n;j++) {
      if (i==r&&j==s) neueMatrix[i][j]=gemeinsamer_Nenner;
      if (i!=r&&j==s) neueMatrix[i][j]=Ausgangsmatrix[i][j];
      if (i==r&&j!=s) neueMatrix[i][j]=-Ausgangsmatrix[i][j];
      if (i!=r&&j!=s) neueMatrix[i][j]=(Ausgangsmatrix[i][j]*neuerNenner-Ausgangsmatrix[i][s]*Ausgangsmatrix[r][j])/gemeinsamer_Nenner;
      }
    }
//  if (Checkbox_Nenner&&(neuerNenner<0)) {
//    for (var i=0;i<m;i++) for (var j=0;j<n;j++) neueMatrix[i][j]=-neueMatrix[i][j];
//    neuerNenner=-neuerNenner;
//    }
  Ausgangsmatrix=neueMatrix;
  gemeinsamer_Nenner=neuerNenner;
  //alert("r="+r+"; s="+s+";\n\n[ ["+Ausgangsmatrix.join("],\n  [")+"] ] / "+gemeinsamer_Nenner);
  }
  return gemeinsamer_Nenner;
  }
  </script>

<script>//https://www.geeksforgeeks.org/javascript-program-to-find-the-determinant-of-a-matrix/

// N is the order of the matrix
const N = 3;
function determinantOfMatrixRecursive(mat, n) {
	if (n === 1) {return mat[0][0]}
	let det = 0n;
	let sign = 1n;
	for (let i = 0; i < n; i++) {
		let submatrix = 
			createSubmatrix(mat, i, n);
		det += sign * mat[0][i] * 
			determinantOfMatrixRecursive(submatrix, n - 1);
		sign = -sign;
	}
	return det;
}

// Function to find sub-matrices of different orders
function createSubmatrix(mat, colToRemove, n) {
	let submatrix = [];
	for (let i = 1; i < n; i++) {
		let newRow = [];
		for (let j = 0; j < n; j++) {
			if (j !== colToRemove) {
				newRow.push(mat[i][j]);
			}
		}
		submatrix.push(newRow);
	}
	return submatrix;
}

let mat2 = [
	[0, 4, -1],
	[0, 0, -2],
	[1, 2, -1]
];

//console.log(
//	"Determinant of the matrix is : ",
//	determinantOfMatrixRecursive(mat2, N)
//);
//alert(determinantOfMatrixRecursive(mat2, N));

function determinantOfMatrixIterative(mat, n) {
	let det = 1;
	let total = 1;
	const temp = Array(n).fill(0);
	for (let i = 0; i < n; i++) {
		let index = i;
		while (index < n && mat[index][i] === 0) {
			index++;
		}
		if (index === n) {
			continue;
		}
		if (index !== i) {
			for (let j = 0; j < n; j++) {
				[mat[i][j], mat[index][j]] = 
				[mat[index][j], mat[i][j]];
			}
			det *= Math.pow(-1, index - i);
		}
		for (let j = 0; j < n; j++) {
			temp[j] = mat[i][j];
		}
		for (let j = i + 1; j < n; j++) {
			const num1 = temp[i];
			const num2 = mat[j][i];
			for (let k = 0; k < n; k++) {
				mat[j][k] = 
					num1 * mat[j][k] - 
					num2 * temp[k];
			}
			total *= num1;
		}
	}
	for (let i = 0; i < n; i++) {
		det *= mat[i][i];
	}
	return det / total;
}

const mat = [
	[8, 1, 2],
	[2, 1, 4],
	[1, 0, 5]
];
//console.log(
//	"Determinant of the matrix is:", 
//	determinantOfMatrixIterative(mat, N));


//alert(determinantOfMatrixIterative(mat, N));

/*
alert(determinantOfMatrixIterative([[-1,1,-2,5],[-2,2,4,-8],[-2,2,6,-8],[-4,1,-2,6]],4)==-108);
alert(determinantOfMatrixRecursive([[-1,1,-2,5],[-2,2,4,-8],[-2,2,6,-8],[-4,1,-2,6]],4)==108);
*/	


  </script>

<script>
let handle=0;
let err=false;
function zufaellig_weiter() {
  let zm=Math.round(Math.random()*(m)-1/2);
  let zn=Math.round(Math.random()*(n)-1/2);
  //alert([zm,zn]);
  t(zm,zn);
  	
  if (err==false) handle=setTimeout(zufaellig_weiter,1000);
  }
  </script>
  
<script>
let Ffert=[];
let XFert=[];
function Berechnung_Koeffizient_aus_J(i,j,td_class,npiv) {
  let Aij=BigInt(event.target.innerHTML);
  let gg=-1,hh=-1,kk=-1,ll=-1,dgh=0,dgl=0,dkh=0,dkl=0;
  if (npiv) {
    if (npiv.length==3) {
      gg=npiv[0];hh=npiv[1];dgh=BigInt(npiv[2]);
      AMERK[gg][hh]=AMERK[gg][hh]+dgh;
      } else {
        gg=npiv[0];hh=npiv[1];kk=npiv[2];ll=npiv[3];
        dgh=BigInt(npiv[4]); dgl=BigInt(npiv[5]); dkh=BigInt(npiv[6]); dkl=BigInt(npiv[7]);
        AMERK[gg][hh]=AMERK[gg][hh]+dgh;
        AMERK[gg][ll]=AMERK[gg][ll]+dgl;
        AMERK[kk][hh]=AMERK[kk][hh]+dkh;
        AMERK[kk][ll]=AMERK[kk][ll]+dkl;
        }
    }
  let RET='';
  let detA=0;

  let RET2='';
  if (U.length==0) {
    RET2=RET2+'<div>F={} bedeutet, alle f<sup>i</sup> stehen so wie anfangs (irgendwo) auf der rechten Seite der Gleichungen.</div>\n\n';
    RET2=RET2+'<div>X={} bedeutet, alle x<sub>j</sub> stehen so wie anfangs (irgendwo) auf der linken Seite der Gleichungen.</div>\n\n';
    } else {
  RET2=RET2+'<div>F=<span class="yy">{'+U+'}</span> bedeutet, <span class="yy">';
  for (let i=0;i<U.length;i++) RET2=RET2+'f<sup>'+U[i]+'</sup>, ';
  RET2=RET2.slice(0,-2)+'</span> stehen (irgendwo) auf der linken Seite der Gleichungen und nicht mehr wie anfangs auf der rechten Seite.</div>\n\n';
  
  RET2=RET2+'<div>X=<span class="xx">{'+V+'}</span> bedeutet, <span class="xx">';
  for (let j=0;j<V.length;j++) RET2=RET2+'x<sub>'+V[j]+'</sub>, ';
  RET2=RET2.slice(0,-2)+'</span> stehen (irgendwo) auf der rechten Seite der Gleichungen und nicht mehr wie anfangs auf der linken Seite.</div>\n\n';
      }

  RET=RET+'<div>Zusätzliche ausführliche Berechnung von <span style="border:solid blue; padding:3px; min-height:20px;">';
  if (j==-1) {
    detA=det(AUV(U,V));
    let stimmt='stimmt überein mit der markierten <span style="border:solid blue; padding:3px">'+gemeinsamer_Nenner+'</span>.';
    if (detA!=gemeinsamer_Nenner) {stimmt='ERROR, keine Übereinstimmung mit Zeilenanfang'; alert(stimmt)}
    RET=RET+'… = '+gemeinsamer_Nenner+' …</span>:</div>\n\n<div style="overflow:auto"><var><mat><op>J</op><co><su>F</su><su>X</su></co></mat> = <det>A<co><su>F</su><su>X</su></co></det> = <det>A<co><su><span class="yy">{'+U+'}</span></su><su><span class="xx">{'+V+'}</span></su></co></det> = '+detA+'</var>, '+stimmt+'</div>\n\n';
    RET=RET+RET2;
    RET=RET+'<div>&nbsp;</div>\n\n';
    RET=RET+'<div>&nbsp;</div>\n\n';
    Ffert=U.slice();
    Xfert=V.slice();
    } else {Ffert=YiMat[i][j].slice(); Xfert=XjMat[i][j].slice()}

  let stimmt='stimmt überein mit der markierten <span style="border:solid blue; padding:3px">'+Aij+'</span>.';
  if (td_class=='xy') {
    g=-1-D[j];
    h=B[i];
    let Jg=U.indexOf(g);
    let Jh=V.indexOf(h);
    detA=det(AUV(YiMat[i][j],XjMat[i][j]));
    let Vorzeichen=BigInt((-1)**(Jg+Jh));
    if (Vorzeichen*detA!=Aij) {stimmt='ERROR, keine Übereinstimmung mit der markierten '+Aij; alert(stimmt)}
    RET=RET+'… '+Aij+' · f<sup>'+g+' (=g)</sup> … = … x<sub>'+h+' (=h)</sub></span>:</div>';
    RET=RET+'<div style="white-space:nowrap; soverflow:auto"> <var><mat><op>J</op><co><su>F<mg/></su><su>X<mh/></su></co></mat> = (&minus;1)<sup><span style="color:DarkGreen">J(g)</span>+<span style="color:brown">J(h)</span></sup> · <det>A<co><su>F<mg/></su><su>X<mh/></su></co></det> = (&minus;1)<sup>'+Jg+'+'+Jh+'</sup> · <det>A<co><su><span class="yy">{'+U+'}</span>&setminus;{'+g+'}</su><su><span class="xx">{'+V+'}</span>&setminus;{'+h+'}</su></co></det> = (&minus;1)<sup>'+(Jg+Jh)+'</sup> · <det>A<co><su><span class="pyy">{'+YiMat[i][j]+'}</span></su><su><span class="pxx">{'+XjMat[i][j]+'}</span></su></co></det> = ('+Vorzeichen+') · ('+detA+') = '+(Vorzeichen*detA)+'</var>, '+stimmt+'</div>';
    RET=RET+RET2;
    RET=RET+'<div>In {'+U+'}&setminus;{'+g+'}=<span class="pyy">{'+Ffert+'}</span> nimmt Index g='+g+' beim Sortieren vor dem Entfernen die Indexposition J(g)='+Jg+' ein (beginnend bei 0 gezählt).</div>\n\n';
    RET=RET+'<div>In {'+V+'}&setminus;{'+h+'}=<span class="pxx">{'+Xfert+'}</span> nimmt Index h='+h+' beim Sortieren vor dem Entfernen die Indexposition J(h)='+Jh+' ein (beginnend bei 0 gezählt).</div>\n\n';
    RET=RET+'<div>J(g)+J(h) ist ';
    if ((Jg+Jh)%2) RET=RET+'ungerade, also '; else RET=RET+'gerade, also kein '; 
    RET=RET+'zusätzlicher Vorzeichenwechsel bei der Determinante.</div>\n\n';
    }
  if (td_class=='yy') {
    g=-1-D[j];
    k=-1-B[i];
    let Jg=U.indexOf(g);
    let Jk=YiMat[i][j].indexOf(k);
    detA=det(AUV(YiMat[i][j],XjMat[i][j]));
    let Vorzeichen=BigInt((-1)**(Jg+Jk));
    if (Vorzeichen*detA!=Aij) {stimmt='ERROR, keine Übereinstimmung mit der markierten'+Aij; alert(stimmt)}
    RET=RET+'… '+Aij+' · f<sup>'+g+' (=g)</sup> … = … f<sup>'+k+' (=k)</sup></span>:</div>\n\n';
    RET=RET+'<div style="white-space:nowrap; overflow:auto"> <var><mat><op>J</op><co><su>F<mg/><pk/></su><su>X</su></co></mat> = (&minus;1)<sup><span style="color:DarkGreen">J(g)</span>+<span style="color:orange">J(k)</span></sup> · <det>A<co><su>F<mg/><pk/></su><su>X</su></co></det> = (&minus;1)<sup>'+Jg+'+'+Jk+'</sup> · <det>A<co><su><span class="yy">{'+U+'}</span>&setminus;{'+g+'}&cup;{'+k+'}</su><su><span class="xx">{'+V+'}</span></su></co></det> = (&minus;1)<sup>'+(Jg+Jk)+'</sup> · <det>A<co><su><span class="pyy">{'+YiMat[i][j]+'}</span></su><su><span class="xx">{'+XjMat[i][j]+'}</span></su></co></det> = ('+Vorzeichen+') · ('+detA+') = '+(Vorzeichen*detA)+'</var>, '+stimmt+'</div>\n\n';
    RET=RET+RET2;
    RET=RET+'<div>In {'+U+'}&setminus;{'+g+'} nimmt Index g='+g+' beim Sortieren vor dem Entfernen die Indexposition J(g)='+Jg+' ein (beginnend bei 0 gezählt).</div>\n\n';
    RET=RET+'<div>In {'+U+'}&setminus;{'+g+'}&cup;{'+k+'}=<span class="pyy">{'+Ffert+'}</span> nimmt Index k='+k+' nach dem Hinzufügen beim Sortieren die Indexposition J(k)='+Jk+' ein (beginnend bei 0 gezählt).</div>\n\n';
    RET=RET+'<div>J(g)+J(k) ist ';
    if ((Jg+Jk)%2) RET=RET+'ungerade, also '; else RET=RET+'gerade, also kein '; 
    RET=RET+'zusätzlicher Vorzeichenwechsel bei der Determinante.</div>\n\n';
    }
  if (td_class=='xx') {
    l=D[j];
    h=B[i];
    let Xjmerk=V.slice(); Xjmerk.push(l); Xjmerk.sort();
    let Jl=Xjmerk.indexOf(l);
    let Jh=Xjmerk.indexOf(h);
    detA=det(AUV(YiMat[i][j],XjMat[i][j]));
    let Vorzeichen=BigInt((-1)**(Jl+Jh));
    if (Vorzeichen*detA!=Aij) {stimmt='ERROR, keine Übereinstimmung mit der markierten'+Aij; alert(stimmt)}
    RET=RET+'… '+Aij+' · x<sub>'+l+' (=&ell;)</sub> … = … x<sub>'+h+' (=h)</sub></span>:</div>\n\n';
    RET=RET+'<div style="white-space:nowrap; overflow:auto"> <var><mat><op>J</op><co><su>F</su><su>X<pl/><mh/></su></co></mat> = (&minus;1)<sup><span style="color:DarkSlateGray">J(&ell;)</span>+<span style="color:brown">J(h)</span></sup> · <det>A<co><su>F</su><su>X<pl/><mh/></su></co></det> = (&minus;1)<sup>'+Jl+'+'+Jh+'</sup> · <det>A<co><su><span class="yy">{'+U+'}</span></su><su><span class="xx">{'+V+'}</span>&cup;{'+l+'}&setminus;{'+h+'}</su></co></det> = (&minus;1)<sup>'+(Jl+Jh)+'</sup> · <det>A<co><su><span class="yy">{'+YiMat[i][j]+'}</span></su><su><span class="pxx">{'+XjMat[i][j]+'}</span></su></co></det> = ('+Vorzeichen+') · ('+detA+') = '+(Vorzeichen*detA)+'</var>, '+stimmt+'</div>\n\n';
    RET=RET+RET2;
    let zwischen=V.slice(); zwischen.push(l); zwischen.sort();
    RET=RET+'<div>In {'+V+'}&cup;{'+l+'}=<span class="pyx">{'+zwischen+'}</span> nimmt Index &ell;='+l+' nach dem Hinzufügen beim Sortieren die Indexposition J(&ell;)='+Jl+' ein (beginnend bei 0 gezählt).</div>\n\n';
    RET=RET+'<div>In {'+V+'}&cup;{'+l+'}&setminus;{'+h+'}=<span class="pxx">{'+Xfert+'}</span> nimmt Index h='+h+' beim Sortieren vor dem Entfernen die Indexposition J(h)='+Jh+' ein (beginnend bei 0 gezählt).</div>\n\n';
    RET=RET+'<div>J(&ell;)+J(h) ist ';
    if ((Jl+Jh)%2) RET=RET+'ungerade, also '; else RET=RET+'gerade, also kein '; 
    RET=RET+'zusätzlicher Vorzeichenwechsel bei der Determinante.</div>\n\n';
    }
  if (td_class=='yx') {
    l=D[j];
    k=-1-B[i];
    let Jl=XjMat[i][j].indexOf(l);
    let Jk=YiMat[i][j].indexOf(k);
    detA=det(AUV(YiMat[i][j],XjMat[i][j]));
    let Vorzeichen=BigInt((-1)**(Jl+Jk));
    if (Vorzeichen*detA!=Aij) {stimmt='ERROR, keine Übereinstimmung mit der markierten'+Aij; alert(stimmt)}
    RET=RET+'… '+Aij+' · x<sub>'+l+' (=&ell;)</sub> … = … f<sup>'+k+' (=k)</sup></span>:</div>\n\n';
    RET=RET+'<div style="white-space:nowrap; overflow:auto"> <var><mat><op>J</op><co><su>F<pk/></su><su>X<pl/></su></co></mat> = (&minus;1)<sup><span style="color:DarkSlateGray">J(&ell;)</span>+<span style="color:orange">J(k)</span></sup> · <det>A<co><su>F<pk/></su><su>X<pl/></su></co></det> = (&minus;1)<sup>'+Jl+'+'+Jk+'</sup> · <det>A<co><su><span class="yy">{'+U+'}</span>&cup;{'+k+'}</su><su><span class="xx">{'+V+'}</span>&cup;{'+l+'}</su></co></det> = (&minus;1)<sup>'+(Jl+Jk)+'</sup> · <det>A<co><su><span class="pyy">{'+YiMat[i][j]+'}</span></su><su><span class="pxx">{'+XjMat[i][j]+'}</span></su></co></det> = ('+Vorzeichen+') · ('+detA+') = '+(Vorzeichen*detA)+'</var>, '+stimmt+'</div>\n\n';
    RET=RET+RET2;
    RET=RET+'<div>In {'+U+'}&cup;{'+k+'}=<span class="pyy">{'+Ffert+'}</span> nimmt Index k='+k+' nach dem Hinzufügen beim Sortieren die Indexposition J(k)='+Jk+' ein (beginnend bei 0 gezählt).</div>\n\n';
    RET=RET+'<div>In {'+V+'}&cup;{'+l+'}=<span class="pxx">{'+Xfert+'}</span> nimmt Index &ell;='+l+' nach dem Hinzufügen beim Sortieren die Indexposition J(&ell;)='+Jl+' ein (beginnend bei 0 gezählt).</div>\n\n';
    RET=RET+'<div>J(&ell;)+J(k) ist ';
    if ((Jl+Jk)%2) RET=RET+'ungerade, also '; else RET=RET+'gerade, also kein '; 
    RET=RET+'zusätzlicher Vorzeichenwechsel bei der Determinante.</div>\n\n';
    }
  RET=RET+'<div>Aus <var>A</var> werden alle Zeilen herausgestrichen außer die Zeilen <span class="';
  if (td_class=='xx'||td_class==0) RET=RET+'yy'; else RET=RET+'pyy';  
  RET=RET+'">{'+Ffert+'}</span>.</div>\n\n';
  RET=RET+'<div>Aus <var>A</var> werden alle Spalten herausgestrichen außer die Spalten <span class="';
  if (td_class=='yy'||td_class==0) RET=RET+'xx'; else RET=RET+'pxx';
  RET=RET+'">{'+Xfert+'}</span>.</div>\n\n';
  RET=RET+'<div>Es bleiben die Matrixeinträge auf <span class="xy">hellgrauem</span> Hintergrund übrig.</div>\n\n';

  RET=RET+'<div style="display:flex; font-size:1.15rem; align-items:center"><span style="min-width:100px"><det>A<co><su><span class="';
  if (td_class=='xx'||td_class==0) RET=RET+'yy'; else RET=RET+'pyy';
  RET=RET+'">{'+Ffert+'}</span></su><su><span class="';
  if (td_class=='yy'||td_class==0) RET=RET+'xx'; else RET=RET+'pxx';
  RET=RET+'">{'+Xfert+'}</span></su></co></det></span> = ';
  
  let sdgh=''+dgh; if (dgh>=0) sdgh='+'+dgh;
  let sdgl=''+dgl; if (dgl>=0) sdgl='+'+dgl;
  let sdkh=''+dkh; if (dkh>=0) sdkh='+'+dkh;
  let sdkl=''+dkl; if (dkl>=0) sdkl='+'+dkl;
  RET=RET+'det <table style="border-left:solid 2px; border-radius:5px; border-color:black; border-right:solid 2px; margin:10p; text-align:right">';
  for (let i=0;i<m;i++) {
    RET=RET+'<tr>\n';
    for (let j=0;j<n;j++) {
      RET=RET+'  <td class="';
      if (Ffert.indexOf(i)>-1&&Xfert.indexOf(j)>-1) RET=RET+'pxy';
      if (Ffert.indexOf(i)==-1&&Xfert.indexOf(j)>-1) if (td_class=='yy'||td_class==0) RET=RET+'xx'; else RET=RET+'pxx'; 
      if (Ffert.indexOf(i)>-1&&Xfert.indexOf(j)==-1) if (td_class=='xx'||td_class==0) RET=RET+'yy'; else RET=RET+'pyy'; 
      if (Ffert.indexOf(i)==-1&&Xfert.indexOf(j)==-1) RET=RET+'pyx';
      RET=RET+'">';
      let AMij=AMERK[i][j];
      if (npiv) if (npiv.length==3) {
        if ((i==gg)&&(j==hh)) AMij=(AMERK[i][j]-dgh)+sdgh;
        } else {
          if ((i==gg)&&(j==hh)) AMij=(AMERK[i][j]-dgh)+sdgh;
          if ((i==gg)&&(j==ll)) AMij=(AMERK[i][j]-dgl)+sdgl;
          if ((i==kk)&&(j==hh)) AMij=(AMERK[i][j]-dkh)+sdkh;
          if ((i==kk)&&(j==ll)) AMij=(AMERK[i][j]-dkl)+sdkl;
          }
      RET=RET+AMij+'</td>\n';
      }
    RET=RET+'  </tr>\n';
    }
  RET=RET+'</table> = ';
  
  let AUVMAT=AUV(Ffert,Xfert);
  RET=RET+'det<table style="border-left:solid 2px; border-radius:5px; border-color:black; border-right:solid 2px; margin:10p; text-align:right">';
  for (let i=0;i<AUVMAT.length;i++) {
    RET=RET+'<tr>\n';
    for (let j=0;j<AUVMAT[0].length;j++) {
      RET=RET+'  <td class="pxy">'+AUVMAT[i][j]+'</td>\n';
      }
    RET=RET+'  </tr>\n';
    }
  RET=RET+'</table> = '+detA;
  
  if ((AUVMAT.length>2)||((AUVMAT.length==2)&&((detA>100n)|| (detA<-100n)||(AUVMAT[0][0]*AUVMAT[1][1]>100n)||(AUVMAT[0][0]*AUVMAT[1][1]<-100n)||(AUVMAT[0][1]*AUVMAT[1][0]>100n)||(AUVMAT[0][1]*AUVMAT[1][0]<-100n)))) {
    RET=RET+' &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a target="_blank" href="http://wolframalpha.com/input/?i=determinant{';
    for (let i=0;i<AUVMAT.length;i++) {
      RET=RET+'{';
      for (let j=0;j<AUVMAT[0].length;j++) {
        RET=RET+AUVMAT[i][j]+',';
        }
      RET=RET.slice(0,-1)+'},';
      }
    RET=RET.slice(0,-1)+'}">WolframAlpha</a>)';
    }
  RET=RET+'</div>';

  //RET=RET+'<br>'+[i,j,B[i],D[j],td_class,'<br>F-+=',YiMat[i][j],'<br>X+-=',XjMat[i][j],'<br>F=',U,'<br>X=',V,'<br>det',det(AUV(YiMat[i][j],XjMat[i][j]))];

  if (npiv) {
    if (npiv.length==3) {
      Ausgabe_Koeffizient2.innerHTML=RET;
      AMERK[gg][hh]=AMERK[gg][hh]-dgh;
      Pivot2.setAttribute('style','border:solid white;');
      Pivot2.removeAttribute('id');
      event.target.setAttribute('id','Pivot2');
      Pivot2.setAttribute('style','border:solid blue;');
      Pivot2_i=i;
      Pivot2_j=j;
      } else {
        Ausgabe_Koeffizient3.innerHTML=RET;
        AMERK[gg][hh]=AMERK[gg][hh]-dgh;
        AMERK[gg][ll]=AMERK[gg][ll]-dgl;
        AMERK[kk][hh]=AMERK[kk][hh]-dkh;
        AMERK[kk][ll]=AMERK[kk][ll]-dkl;
        Pivot3.setAttribute('style','border:solid white;');
        Pivot3.removeAttribute('id');
        event.target.setAttribute('id','Pivot3');
        Pivot3.setAttribute('style','border:solid blue;');
        Pivot3_i=i;
        Pivot3_j=j;
        }
    } else {
      Ausgabe_Koeffizient.innerHTML=RET;
      Ausgabe_xml.firstChild.nodeValue=HCode2+'\n\n'+RET;
      Pivot.setAttribute('style','border:solid white;');
      Pivot.removeAttribute('id');
      event.target.setAttribute('id','Pivot');
      Pivot.setAttribute('style','border:solid blue;');
      Pivot_i=i;
      Pivot_j=j;
      }
  }
  </script>
<body onload="Los()" style='font-size:80%'>
<p>Testprogramm zu <a href="https://matheplanet.de/matheplanet/nuke/html/article.php?sid=2012" target="_blank">Gleichungen umstellen mit Sylvester&rsquo;s determinant identity</a>. Indizes beginnen mit 0 statt 1.</p>

<p>Ein Klick auf eine <span style='border:solid black'>Variable</span> links vom Gleichheitszeichen tauscht diese mit der Variable rechts vom Gleichheitszeichen.</p>
<p>Ein Klick auf einen <span style='border:solid blue'>Koeffizient</span> berechnet diesen zusätzlich ausführlich nach der <a href='https://matheplanet.de/matheplanet/nuke/html/article.php?sid=2012#Darstellung_IV'>allgemeinen Darstellung IV</a>.</p>

<textarea id="input" cols="80" rows="10" >Ausgangsmatrix=[ 
  [  1,  2,  4,  1,  1,  4,  3,  7,  8 ],
  [  4, -1, -3,  1, -1, -2,  5,  1,  9 ],
  [  3, -2, -1,  2,  4,  4, -8, -1,  7 ],
  [  2,  2,  4,  5,  1,  4,  3,  5,  8 ],
  [  4, -4, -3,  1, -2, -2,  7,  1,  7 ],
  [  3, -2, -3,  2,  3,  6, -8, -1,  2 ],
  [  1, -4, -2,  1, -3, -2,  6,  1,  8 ],
  [  3, -1, -3,  4,  3,  5, -8, -7,  2 ],
  [  3,  2, -1, -4, -1,  6,  2,  5,  2 ] ] ;
  
Ausgangsmatrix2=[ 
  [ 24, -2, -4, -1, -1, -4, -3, -7, -8 ],
  [ -4, 20, -3, -1, -1, -2, -5, -1, -9 ],
  [ -3, -2, 24, -2, -4, -4, -8, -1, -7 ],
  [ -2, -2, -4, 17, -1, -4, -3, -5, -8 ],
  [ -4, -4, -3, -1, 18, -2, -7, -1, -7 ],
  [ -3, -2, -3, -2, -3, 30, -8, -1, -2 ],
  [ -1, -4, -2, -1, -3, -2, 45, -1, -8 ],
  [ -3, -1, -3, -4, -3, -5, -8, 23, -2 ],
  [ -3, -2, -1, -4, -1, -6, -2, -5, 52 ] ] ;
</textarea>

<button onclick="clearTimeout(handle); sign=1; signarray=[]; gemeinsamer_Nenner=1; Los()">neu beginnen</button>
<button onclick="err=false;zufaellig_weiter()">zufällig weiter</button>
<button onclick="clearTimeout(handle)">anhalten</button>
<button onclick="clearTimeout(handle); p=hist.pop(); t(p[0],p[1]); hist.pop()">zurueck</button>
<input id="Checkbox_Nenner" type="checkbox"/> gemeinsamer Nenner immer positiv

<style>
/*Schrift: Die Aufmerksamkeit soll anfangs auf dem Text liegen, die Gleichungen etwas unauffälliger.*/
mat, det, var, gl, wable {font-family:Courier momospace; font-style:italic; font-size:1.15rem; color:SlateGray} /*Anfangswert war Gray*/
/*font-family ist wohl nicht verstellbar.*/
/*1.15rem statt 1.15em ist eine Notlösung, weil det manchmal in var enthalten ist*/

/*Schriftgröße der Indizes: maximal soviel, dass Gleichungen 62 bis 65 komplett sichtbar sind ohne Umschaltung auf Scrollbalken*/
su, sub, sup {font-size:85%} /*Anfangswert war 75%*/

/*weitere Gestaltung*/
sub {white-space:nowrap}
sup {white-space:nowrap; padding-left:2px} /* padding-left wegen dem kursiven f in f<sup>g</sup>*/ 
mat,det {display:inline-flex; align-items:center; padding:2px; border-radius:0px; margin:0px; white-space:nowrap}
//det {border-left:solid 1px; border-right:solid 1px; margin:2px}
co {display:inline-flex; flex-direction:column}
su {display:table-cell; line-height:100%}
var {white-space:pre}

pg:before {content:"∪{g}"; color:DarkGreen}
ph:before {content:"∪{h}"; color:brown}
pk:before {content:"∪{k}"; color:orange}
pl:before {content:"∪{ℓ}"; color:DarkSlateGray}
pp:before {content:"∪{p}"; color:DarkBlue}
pq:before {content:"∪{q}"; color:DeepSkyBlue}
pr:before {content:"∪{r}"; color:red} /*<span style="color:red">&cup;{r}</span> g h k l p q r s*/
ps:before {content:"∪{s}"; color:violet}

mg:before {content:"∖{g}"; color:DarkGreen}
mh:before {content:"∖{h}"; color:brown}
mk:before {content:"∖{k}"; color:orange}
ml:before {content:"∖{ℓ}"; color:DarkSlateGray}
mp:before {content:"∖{p}"; color:DarkBlue}
mq:before {content:"∖{q}"; color:DeepSkyBlue}
mr:before {content:"∖{r}"; color:red}
ms:before {content:"∖{s}"; color:violet}

op {font-style:normal}

gl {display:inline-block; border:solid 1px; border-radius:20px; padding:1px; padding-right: 2px; background-color:snow; width:1.7em; width:1lh; text-align:center} /* 1lh geht nicht überall, deshalb vorher 1.7em*/

whr {display:block; height:2lh; background-image:linear-gradient(white, LightGray 0.1lh);}

wable {display:table; border-collapse:separate; border-spacing:2px; }
wbody {display:table-row-group;}
wr {display:table-row;}
wd {display:table-cell;white-space:nowrap; padding:1px; borderx:solid pink 1px}

bem {display:none; color:green}

/* Fahrrad auch so groß wie die Schrift für die Gleichungen*/
#Abschnitt_2, #Abschnitt_3, #Abschnitt_4, #Abschnitt_5, #Abschnitt_6, #Abschnitt_7, #Abschnitt_8, #Abschnitt_9, #Abschnitt_10, #Abschnitt_11, #ßAbschnitt_12, #Abschnitt_13, #Abschnitt_14, #Abschnitt_15, #Abschnitt_16 {font-size:1.15rem} 
  </style>
<p style='display:flex; flex-direvtion:row; overflow:auto;'><div id="HCode"> </div></p>
<div id="Ausgabe_Koeffizient">
  </div>
<!--geeigneter Code für den Kommentarbereich (noch nicht fertig):-->
<div id="Ausgabe_xml" style="display:none; font-family:Courier,Monospace; white-space:pre-wrap">
  </div>
<div id="Logfile" style="display:none; white-space:pre; font-family:Courier,Monospace; font-size:70%">
  </div>
<div id="Ausgabe">
  </div>

<script>
window.addEventListener('error',function(event) {alert('Fehlerausgabe von window.addEventListener("error",...)\n'+event+'\n'+event.error.name+'\n'+event.error.cause+'\n'+event.error.stack+'\n'+event.error.columnNumber+'\n'+event.error.fileName+'\n'+event.error.lineNumber+'\n'+event.error.message)});
window.onerror=function(message, file, line, col, error) {alert('Fehlerausgabe von window.onerror\nmessage '+message+'\nfile: '+file+'\nline: '+line+'\ncol: '+col+'\nerror: '+error)};

let Matrix_2=[];
let Matrix_3=[];
let alter_gemeinsamer_Nenner=0n;
let neuer_gemeinsamer_Nenner=0n;
let alter_gemeinsamer_Nenner3=0n;
let neuer_gemeinsamer_Nenner3=0n;

function bestimme_Matrix_2() {
  g=id_g.value*1;
  h=id_h.value*1;
  d=BigInt(id_d.value);//für a(g,h)+d
  npiv2=[g,h,d];
  Matrix_2=structuredClone(Ausgangsmatrix);
  alter_gemeinsamer_Nenner=gemeinsamer_Nenner;
  neuer_gemeinsamer_Nenner=gemeinsamer_Nenner;
  if ((D.indexOf(h)==-1)&&(B.indexOf(-g-1)==-1)) {
    for (let i=0;i<Matrix_2[0].length;i++) for (let j=0;j<Matrix_2.length;j++) 
      Matrix_2[j][i]=Matrix_2[j][i]+d*(Ausgangsmatrix[j][i]*Ausgangsmatrix[B.indexOf(h)][D.indexOf(-g-1)]-Ausgangsmatrix[B.indexOf(h)][i]*Ausgangsmatrix[j][D.indexOf(-g-1)])/gemeinsamer_Nenner;
    neuer_gemeinsamer_Nenner=gemeinsamer_Nenner+d*Ausgangsmatrix[B.indexOf(h)][D.indexOf(-g-1)];
    }
  if ((D.indexOf(h)==-1)&&(B.indexOf(-g-1)>-1)) {
    for (let i=0;i<Matrix_2[0].length;i++) 
      Matrix_2[B.indexOf(-g-1)][i]=Matrix_2[B.indexOf(-g-1)][i]+d*Ausgangsmatrix[B.indexOf(h)][i];
    }
  if ((D.indexOf(h)>-1)&&(B.indexOf(-g-1)==-1)) {
    for (let j=0;j<Matrix_2.length;j++) 
      Matrix_2[j][D.indexOf(h)]=Matrix_2[j][D.indexOf(h)]-d*Ausgangsmatrix[j][D.indexOf(-g-1)];
    }
  if ((D.indexOf(h)>-1)&&(B.indexOf(-g-1)>-1)) Matrix_2[B.indexOf(-g-1)][D.indexOf(h)]=Matrix_2[B.indexOf(-g-1)][D.indexOf(h)]+d*gemeinsamer_Nenner;
  Logfile_Matrix_2.innerHTML='D=['+D+']\nB=['+B+']\n'+((D.indexOf(g)-1)&&(B.indexOf(-h-1)>-1));
  }

function bestimme_Matrix_3() {
  g=id_g3.value*1;
  h=id_h3.value*1;
  k=id_k.value*1;
  l=id_l.value*1;
  dgh=BigInt(id_dgh.value);//für a(g,h)+dgh
  dgl=BigInt(id_dgl.value);//für a(g,l)+dgl
  dkh=BigInt(id_dkh.value);//für a(k,h)+dkh
  dkl=BigInt(id_dkl.value);//für a(k,l)+dkl
  npiv3=[g,h,k,l,[dgh,dgl,dkh,dkl]];
  Matrix_3=structuredClone(Ausgangsmatrix);
  alter_gemeinsamer_Nenner3=gemeinsamer_Nenner;
  neuer_gemeinsamer_Nenner3=gemeinsamer_Nenner;
  
  if ((D.indexOf(h)==-1)&&(B.indexOf(-g-1)==-1)&&(D.indexOf(l)==-1)&&(B.indexOf(-k-1)==-1)) {
    for (let i=0;i<Matrix_2[0].length;i++) for (let j=0;j<Matrix_2.length;j++) {
      let det3=det([
        [Ausgangsmatrix[j][i],Ausgangsmatrix[j][D.indexOf(-g-1)],Ausgangsmatrix[j][D.indexOf(-k-1)]],
        [Ausgangsmatrix[B.indexOf(h)][i],Ausgangsmatrix[B.indexOf(h)][D.indexOf(-g-1)],Ausgangsmatrix[B.indexOf(h)][D.indexOf(-k-1)]],
        [Ausgangsmatrix[B.indexOf(l)][i],Ausgangsmatrix[B.indexOf(l)][D.indexOf(-g-1)],Ausgangsmatrix[B.indexOf(l)][D.indexOf(-k-1)]]
        ]);
      let quot3=det3/gemeinsamer_Nenner/gemeinsamer_Nenner;
      let prod3=quot3*gemeinsamer_Nenner*gemeinsamer_Nenner;
      if (prod3!=det3) alert('Error\ndet='+det3+'\nprod='+prod3);
      Matrix_3[j][i]=Matrix_3[j][i]+det([[dgh,dgl],[dkh,dkl]])*quot3;
      }
    neuer_gemeinsamer_Nenner3=neuer_gemeinsamer_Nenner3+det([[dgh,dgl],[dkh,dkl]])*(
      Ausgangsmatrix[B.indexOf(h)][D.indexOf(-g-1)]*Ausgangsmatrix[B.indexOf(l)][D.indexOf(-k-1)]-
      Ausgangsmatrix[B.indexOf(h)][D.indexOf(-k-1)]*Ausgangsmatrix[B.indexOf(l)][D.indexOf(-g-1)])/gemeinsamer_Nenner;
    }

  if ((D.indexOf(h)==-1)&&(B.indexOf(-g-1)>-1)&&(D.indexOf(l)==-1)&&(B.indexOf(-k-1)==-1)) 
    for (let i=0;i<Matrix_2[0].length;i++)
      Matrix_3[B.indexOf(-g-1)][i]=Matrix_3[B.indexOf(-g-1)][i]+det([[dgh,dgl],[dkh,dkl]])
      *det([[Ausgangsmatrix[B.indexOf(h)][i],Ausgangsmatrix[B.indexOf(h)][D.indexOf(-k-1)]],
           [Ausgangsmatrix[B.indexOf(l)][i],Ausgangsmatrix[B.indexOf(l)][D.indexOf(-k-1)]]])/gemeinsamer_Nenner;
  if ((D.indexOf(h)==-1)&&(B.indexOf(-g-1)==-1)&&(D.indexOf(l)==-1)&&(B.indexOf(-k-1)>-1)) 
    for (let i=0;i<Matrix_2[0].length;i++)
      Matrix_3[B.indexOf(-k-1)][i]=Matrix_3[B.indexOf(-k-1)][i]-det([[dgh,dgl],[dkh,dkl]])
      *det([[Ausgangsmatrix[B.indexOf(h)][i],Ausgangsmatrix[B.indexOf(h)][D.indexOf(-g-1)]],
           [Ausgangsmatrix[B.indexOf(l)][i],Ausgangsmatrix[B.indexOf(l)][D.indexOf(-g-1)]]])/gemeinsamer_Nenner;
  if ((D.indexOf(h)>-1)&&(B.indexOf(-g-1)==-1)&&(D.indexOf(l)==-1)&&(B.indexOf(-k-1)==-1)) 
    for (let j=0;j<Matrix_2[0].length;j++)
      Matrix_3[j][D.indexOf(h)]=Matrix_3[j][D.indexOf(h)]+det([[dgh,dgl],[dkh,dkl]])
      *det([[Ausgangsmatrix[B.indexOf(l)][D.indexOf(-g-1)],Ausgangsmatrix[B.indexOf(l)][D.indexOf(-k-1)]],
            [Ausgangsmatrix[j][D.indexOf(-g-1)],Ausgangsmatrix[j][D.indexOf(-k-1)]]])/gemeinsamer_Nenner;
  if ((D.indexOf(h)==-1)&&(B.indexOf(-g-1)==-1)&&(D.indexOf(l)>-1)&&(B.indexOf(-k-1)==-1)) 
    for (let j=0;j<Matrix_2[0].length;j++)
      Matrix_3[j][D.indexOf(l)]=Matrix_3[j][D.indexOf(l)]-det([[dgh,dgl],[dkh,dkl]])
      *det([[Ausgangsmatrix[B.indexOf(h)][D.indexOf(-g-1)],Ausgangsmatrix[B.indexOf(h)][D.indexOf(-k-1)]],
            [Ausgangsmatrix[j][D.indexOf(-g-1)],Ausgangsmatrix[j][D.indexOf(-k-1)]]])/gemeinsamer_Nenner;


  if ((D.indexOf(h)==-1)&&(B.indexOf(-g-1)==-1)&&(D.indexOf(l)>-1)&&(B.indexOf(-k-1)>-1)) Matrix_3[B.indexOf(-k-1)][D.indexOf(l)]=Matrix_3[B.indexOf(-k-1)][D.indexOf(l)]+det([[dgh,dgl],[dkh,dkl]])*Ausgangsmatrix[B.indexOf(h)][D.indexOf(-g-1)];
  if ((D.indexOf(h)>-1)&&(B.indexOf(-g-1)>-1)&&(D.indexOf(l)==-1)&&(B.indexOf(-k-1)==-1)) Matrix_3[B.indexOf(-g-1)][D.indexOf(h)]=Matrix_3[B.indexOf(-g-1)][D.indexOf(h)]+det([[dgh,dgl],[dkh,dkl]])*Ausgangsmatrix[B.indexOf(l)][D.indexOf(-k-1)];
  if ((D.indexOf(h)>-1)&&(B.indexOf(-g-1)==-1)&&(D.indexOf(l)==-1)&&(B.indexOf(-k-1)>-1)) Matrix_3[B.indexOf(-k-1)][D.indexOf(h)]=Matrix_3[B.indexOf(-k-1)][D.indexOf(h)]-det([[dgh,dgl],[dkh,dkl]])*Ausgangsmatrix[B.indexOf(l)][D.indexOf(-g-1)];
  if ((D.indexOf(h)==-1)&&(B.indexOf(-g-1)>-1)&&(D.indexOf(l)>-1)&&(B.indexOf(-k-1)==-1)) Matrix_3[B.indexOf(-g-1)][D.indexOf(l)]=Matrix_3[B.indexOf(-g-1)][D.indexOf(l)]-det([[dgh,dgl],[dkh,dkl]])*Ausgangsmatrix[B.indexOf(h)][D.indexOf(-k-1)];

  if ((D.indexOf(h)==-1)&&(B.indexOf(-g-1)==-1)) {
    for (let i=0;i<Matrix_2[0].length;i++) for (let j=0;j<Matrix_2.length;j++) 
      Matrix_3[j][i]=Matrix_3[j][i]+dgh*(Ausgangsmatrix[j][i]*Ausgangsmatrix[B.indexOf(h)][D.indexOf(-g-1)]-Ausgangsmatrix[B.indexOf(h)][i]*Ausgangsmatrix[j][D.indexOf(-g-1)])/gemeinsamer_Nenner;
    neuer_gemeinsamer_Nenner3=neuer_gemeinsamer_Nenner3+dgh*Ausgangsmatrix[B.indexOf(h)][D.indexOf(-g-1)];
    }
  if ((D.indexOf(l)==-1)&&(B.indexOf(-g-1)==-1)) {
    for (let i=0;i<Matrix_2[0].length;i++) for (let j=0;j<Matrix_2.length;j++) 
      Matrix_3[j][i]=Matrix_3[j][i]+dgl*(Ausgangsmatrix[j][i]*Ausgangsmatrix[B.indexOf(l)][D.indexOf(-g-1)]-Ausgangsmatrix[B.indexOf(l)][i]*Ausgangsmatrix[j][D.indexOf(-g-1)])/gemeinsamer_Nenner;
    neuer_gemeinsamer_Nenner3=neuer_gemeinsamer_Nenner3+dgl*Ausgangsmatrix[B.indexOf(l)][D.indexOf(-g-1)];
    }
  if ((D.indexOf(h)==-1)&&(B.indexOf(-k-1)==-1)) {
    for (let i=0;i<Matrix_2[0].length;i++) for (let j=0;j<Matrix_2.length;j++) 
      Matrix_3[j][i]=Matrix_3[j][i]+dkh*(Ausgangsmatrix[j][i]*Ausgangsmatrix[B.indexOf(h)][D.indexOf(-k-1)]-Ausgangsmatrix[B.indexOf(h)][i]*Ausgangsmatrix[j][D.indexOf(-k-1)])/gemeinsamer_Nenner;
    neuer_gemeinsamer_Nenner3=neuer_gemeinsamer_Nenner3+dkh*Ausgangsmatrix[B.indexOf(h)][D.indexOf(-k-1)];
    }
  if ((D.indexOf(l)==-1)&&(B.indexOf(-k-1)==-1)) {
    for (let i=0;i<Matrix_2[0].length;i++) for (let j=0;j<Matrix_2.length;j++) 
      Matrix_3[j][i]=Matrix_3[j][i]+dkl*(Ausgangsmatrix[j][i]*Ausgangsmatrix[B.indexOf(l)][D.indexOf(-k-1)]-Ausgangsmatrix[B.indexOf(l)][i]*Ausgangsmatrix[j][D.indexOf(-k-1)])/gemeinsamer_Nenner;
    neuer_gemeinsamer_Nenner3=neuer_gemeinsamer_Nenner3+dkl*Ausgangsmatrix[B.indexOf(l)][D.indexOf(-k-1)];
    }

  if ((D.indexOf(h)==-1)&&(B.indexOf(-g-1)>-1)) {
    for (let i=0;i<Matrix_2[0].length;i++) 
      Matrix_3[B.indexOf(-g-1)][i]=Matrix_3[B.indexOf(-g-1)][i]+dgh*Ausgangsmatrix[B.indexOf(h)][i];
    }
  if ((D.indexOf(l)==-1)&&(B.indexOf(-g-1)>-1)) {
    for (let i=0;i<Matrix_2[0].length;i++) 
      Matrix_3[B.indexOf(-g-1)][i]=Matrix_3[B.indexOf(-g-1)][i]+dgl*Ausgangsmatrix[B.indexOf(l)][i];
    }
  if ((D.indexOf(h)==-1)&&(B.indexOf(-k-1)>-1)) {
    for (let i=0;i<Matrix_2[0].length;i++) 
      Matrix_3[B.indexOf(-k-1)][i]=Matrix_3[B.indexOf(-k-1)][i]+dkh*Ausgangsmatrix[B.indexOf(h)][i];
    }
  if ((D.indexOf(l)==-1)&&(B.indexOf(-k-1)>-1)) {
    for (let i=0;i<Matrix_2[0].length;i++) 
      Matrix_3[B.indexOf(-k-1)][i]=Matrix_3[B.indexOf(-k-1)][i]+dkl*Ausgangsmatrix[B.indexOf(l)][i];
    }

  if ((D.indexOf(h)>-1)&&(B.indexOf(-g-1)==-1)) {
    for (let j=0;j<Matrix_2.length;j++) 
      Matrix_3[j][D.indexOf(h)]=Matrix_3[j][D.indexOf(h)]-dgh*Ausgangsmatrix[j][D.indexOf(-g-1)];
    }
  if ((D.indexOf(l)>-1)&&(B.indexOf(-g-1)==-1)) {
    for (let j=0;j<Matrix_2.length;j++) 
      Matrix_3[j][D.indexOf(l)]=Matrix_3[j][D.indexOf(l)]-dgl*Ausgangsmatrix[j][D.indexOf(-g-1)];
    }
  if ((D.indexOf(h)>-1)&&(B.indexOf(-k-1)==-1)) {
    for (let j=0;j<Matrix_2.length;j++) 
      Matrix_3[j][D.indexOf(h)]=Matrix_3[j][D.indexOf(h)]-dkh*Ausgangsmatrix[j][D.indexOf(-k-1)];
    }
  if ((D.indexOf(l)>-1)&&(B.indexOf(-k-1)==-1)) {
    for (let j=0;j<Matrix_2.length;j++) 
      Matrix_3[j][D.indexOf(l)]=Matrix_3[j][D.indexOf(l)]-dkl*Ausgangsmatrix[j][D.indexOf(-k-1)];
    }
  if ((D.indexOf(h)>-1)&&(B.indexOf(-g-1)>-1)) Matrix_3[B.indexOf(-g-1)][D.indexOf(h)]=Matrix_3[B.indexOf(-g-1)][D.indexOf(h)]+dgh*gemeinsamer_Nenner;
  if ((D.indexOf(l)>-1)&&(B.indexOf(-g-1)>-1)) Matrix_3[B.indexOf(-g-1)][D.indexOf(l)]=Matrix_3[B.indexOf(-g-1)][D.indexOf(l)]+dgl*gemeinsamer_Nenner;
  if ((D.indexOf(h)>-1)&&(B.indexOf(-k-1)>-1)) Matrix_3[B.indexOf(-k-1)][D.indexOf(h)]=Matrix_3[B.indexOf(-k-1)][D.indexOf(h)]+dkh*gemeinsamer_Nenner;
  if ((D.indexOf(l)>-1)&&(B.indexOf(-k-1)>-1)) Matrix_3[B.indexOf(-k-1)][D.indexOf(l)]=Matrix_3[B.indexOf(-k-1)][D.indexOf(l)]+dkl*gemeinsamer_Nenner;
  }
  </script>

<hr/>
<p>Jetzt die gleiche Umformung für die mit 
  <code>a(
    <input id='id_g' size='1' value='0'/>,
    <input id='id_h' size='1' value='1'/>)+<input id='id_d' size='2' value='1'/></code> 
  abgeänderte Ausgangsmatrix <span><button onclick='bestimme_Matrix_2();Ausgabe()'>neu berechnen</button></span>:</p>
<p style='display:flex; flex-direction:row; overflow:auto;'><div id="id_HCode_Matrix_2"> </div></p>
  </div>
<div id="Ausgabe_Koeffizient2">
  </div>
<div id="Logfile_Matrix_2" style="display:non; white-space:pre; font-family:Courier,Monospace; font-size:70%">xxx
  </div>

<hr/>
<span id='aktuell'> </span>
<p>Nun nochmal für die mit </p>
<div>  <code>a(g,h)+<input id='id_dgh' size='2' value='2'/></code> </div>
<div>  <code>a(g,l)+<input id='id_dgl' size='2' value='3'/></code> </div>
<div>  <code>a(k,h)+<input id='id_dkh' size='2' value='5'/></code> </div>
<div>  <code>a(k,l)+<input id='id_dkl' size='2' value='7'/></code> </div>
<div>  <code>mit g=<input id='id_g3' size='1' value='1'/>, h=<input id='id_h3' size='1' value='2'/></code> </div>
<div>  <code>und k=<input id='id_k' size='1' value='3'/>, l=<input id='id_l' size='1' value='4'/></code> </div>
    
<p>abgeänderte Ausgangsmatrix <span><button onclick='bestimme_Matrix_3();Ausgabe()'>neu berechnen</button></span>:</p>
<p style='display:flex; flex-direction:row; overflow:auto;'><div id="id_HCode_Matrix_3"> </div></p>
<div id="Ausgabe_Koeffizient3">
  </div>

  </body>
  </html>
<!--jetzt noch
ok Bigint
.. Gleichungsnummern
ok Error mit Halt
ok Nenner positiv
.. den style fehler bei det
nö u als Komplement von U
nö nochmal xmlns probieren
-->
